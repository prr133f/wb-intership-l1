# №1. Какой самый эффективный способ конкатенации строк?
> Самый эффективный способ - использование билдера
```go
b := &strings.Builder{}

b.WriteString("Hello, ")
b.WriteString("world!")

fmt.Println(b.String()) // Hello, world!
```

# №2. Что такое интерфейсы, как они применяются в Go?
> Интерфейс - тип данных, описывающий поведение других структур.
```go
type Reader interface{
    Read() string
}

// Создадим структуру, реализующую интерейс Reader
type Book struct {
    Author string
    Title string
    Data string
}

func (b Book) Read() string {
    return b.Data
}
```

# №3. Чем отличаются RWMutex от Mutex?
> RWMutex разделяет блокировку для чтения и для записи. 
При блокировке на чтение, у других горутин сохраняется вохможность на чтение, а горутины, желающие заблокировать мьютекс на запись - засыпают. 
При блокировке на запись, RWMutex ведет себя так же, как обычный Mutex.

# №4. Чем отличаются буферизированные и не буферизированные каналы?
> Буферизированные каналы имеют вместимость, в отличии от не буферизированных.
Запись в заполненный буферизированный канал заставит горутину заснуть.
Чтение из пустого канала заставит горутину заснуть.

# №5. Какой размер у структуры struct{}{}?
> Нулевой.
```go
t := struct{}{}

fmt.Println(unsafe.Sizeof(t)) // 0
```

# №6. Есть ли в Go перегрузка методов или операторов?
> Перегрузки в Go нет. Предлагается давать различные имена функциям.

# №7. В какой последовательности будут выведены элементы map[int]int?

Пример:
m[0]=1
m[1]=124
m[2]=281

> В случайном порядке.

# №8. В чем разница make и new?
> make возвращает объект, тогда как new - указатель на созданный объект.

# №9. Сколько существует способов задать переменную типа slice или map?
```go
var s []int
s1 := []int{}
s2 := make([]int)
s3 := new([]int)
```
> 4

# №10. Что выведет данная программа и почему?
```go
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```
> В update() изменяется значение указателя, а не значение, взятое по указателю. Измененное значение указателя остается в локальной области видимости.

# №11. Что выведет данная программа и почему?
```go
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```
> Программа выдаст deadlock, так как объект WaitGroup передается не по указателю, следовательно копируется для каждой горутины, а main ожидает обнуления базового объекта, который не изменяется.

# №12. Что выведет данная программа и почему?
```go
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```
> 0
>
> Такой ответ мы получим из-за того, что в условном операторе создается локальная переменная n, не влияющая не внешнюю.

# №13. Что выведет данная программа и почему?
```go
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```
> [100, 2, 3, 4, 5]
>
> 6 не будет добавлена в слайс, потому что append создает новый, а не расширяет старый слайс.

# №14. Что выведет данная программа и почему?
```go
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```
> ["b", "b", "a"]
> ["a", "a"]
>
> Это произойдет потому, что в анонимной функции создается локальный объект slice.
